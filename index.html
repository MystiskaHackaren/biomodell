<html lang="sv">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Min AI-Modell (Keras/TFJS) - Tokyo Drift Edition</title>
<script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@latest"></script>
<link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&family=Racing+Sans+One&display=swap" rel="stylesheet">
<style>
body {
font-family: 'Orbitron', sans-serif;
background: linear-gradient(135deg, #000000 0%, #1a1a1a 100%);
color: #00ffff; /* Neon cyan */
margin: 0;
padding: 0;
overflow: hidden;
position: relative;
min-height: 100vh;
}
body::before {
content: '';
position: absolute;
top: 0;
left: 0;
width: 100%;
height: 100%;
background: url('data:image/svg+xml,%3Csvg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100"%3E%3Crect width="100" height="100" fill="none"/%3E%3Cpath d="M0 50 L100 50" stroke="%2300ffff" stroke-width="2" stroke-dasharray="5,5" opacity="0.2"/%3E%3Cpath d="M50 0 L50 100" stroke="%23ff00ff" stroke-width="2" stroke-dasharray="5,5" opacity="0.2"/%3E%3C/svg%3E') repeat;
opacity: 0.1;
animation: drift-bg 20s linear infinite;
}
@keyframes drift-bg {
0% { background-position: 0 0; }
100% { background-position: 200% 200%; }
}
.container {
max-width: 700px;
margin: 4rem auto;
padding: 2rem;
background: rgba(0, 0, 0, 0.8);
border: 2px solid #ff00ff; /* Neon pink border */
border-radius: 15px;
box-shadow: 0 0 30px #00ffff, 0 0 60px #ff00ff;
position: relative;
z-index: 1;
animation: neon-pulse 2s infinite alternate;
}
@keyframes neon-pulse {
0% { box-shadow: 0 0 10px #00ffff, 0 0 20px #ff00ff; }
100% { box-shadow: 0 0 30px #00ffff, 0 0 60px #ff00ff; }
}
h1 {
font-family: 'Racing Sans One', cursive;
color: #ff0000; /* Racing red */
text-shadow: 0 0 10px #ff0000, 0 0 20px #ff00ff;
font-size: 3rem;
text-align: center;
margin-bottom: 1rem;
letter-spacing: 2px;
animation: speed-in 1s ease-out;
}
@keyframes speed-in {
0% { transform: translateX(-100%); opacity: 0; }
100% { transform: translateX(0); opacity: 1; }
}
p {
text-align: center;
font-size: 1.2rem;
margin-bottom: 2rem;
color: #ffffff;
text-shadow: 0 0 5px #00ffff;
}
textarea {
width: 100%;
height: 120px;
background: rgba(255, 255, 255, 0.1);
border: 2px solid #00ffff;
border-radius: 10px;
padding: 15px;
color: #ffffff;
font-size: 1.1rem;
resize: none;
box-shadow: 0 0 15px #00ffff;
transition: box-shadow 0.3s;
}
textarea:focus {
outline: none;
box-shadow: 0 0 30px #00ffff, 0 0 50px #ff00ff;
}
button {
display: block;
width: 100%;
padding: 15px;
font-family: 'Racing Sans One', cursive;
font-size: 1.5rem;
background: linear-gradient(135deg, #ff0000, #ff00ff);
color: #ffffff;
border: none;
border-radius: 10px;
cursor: pointer;
margin: 1.5rem 0;
text-shadow: 0 0 5px #000000;
box-shadow: 0 0 20px #ff0000;
transition: transform 0.2s, box-shadow 0.2s;
animation: button-drift 3s infinite alternate;
}
@keyframes button-drift {
0% { transform: skewX(0deg); }
100% { transform: skewX(5deg); }
}
button:hover {
transform: scale(1.05) skewX(10deg);
box-shadow: 0 0 40px #ff0000, 0 0 60px #ff00ff;
}
button:disabled {
background: linear-gradient(135deg, #666666, #999999);
box-shadow: none;
cursor: not-allowed;
animation: none;
}
#result {
font-family: 'Orbitron', sans-serif;
font-size: 2rem;
text-align: center;
padding: 1.5rem;
background: rgba(0, 0, 0, 0.7);
border: 2px dashed #ff00ff;
border-radius: 15px;
margin-top: 2rem;
text-shadow: 0 0 10px #ffffff;
animation: result-flash 1s infinite alternate;
}
@keyframes result-flash {
0% { color: #00ffff; }
100% { color: #ff00ff; }
}
#debug-box {
margin-top: 3rem;
padding: 1.5rem;
background: rgba(0, 0, 0, 0.6);
border: 1px solid #00ffff;
border-radius: 10px;
max-height: 200px;
overflow-y: auto;
font-family: monospace;
color: #00ff00; /* Green matrix style */
box-shadow: 0 0 20px #00ff00;
}
.log-entry {
margin-bottom: 0.5rem;
animation: fade-in 0.5s;
}
@keyframes fade-in {
0% { opacity: 0; }
100% { opacity: 1; }
}
.log-error { color: #ff0000; text-shadow: 0 0 5px #ff0000; }
.log-success { color: #00ff00; text-shadow: 0 0 5px #00ff00; }
</style>
</head>
<body>
<div class="container">
<h1>Testa min text-AI</h1>
<p>Skriv en mening nedan (t.ex. "maten var god" eller "jag är arg").</p>
        <textarea id="textInput" placeholder="Skriv din text här..."></textarea>
        

        <button id="predictBtn" onclick="runPrediction()" disabled>⏳ Initierar...</button>
        Resultatet visas här...
        
            Debug-logg startad...
        
    
    <script>
        let model;
        let metadata;
        // VIKTIGT: Vi tvingar denna till 256 eftersom din modell kräver det
        const SEQUENCE_LENGTH = 256;
        function log(message, type = 'info') {
            const box = document.getElementById('debug-box');
            const entry = document.createElement('div');
            entry.className = 'log-entry';
            const time = new Date().toLocaleTimeString();
            entry.innerHTML = `[${time}] ${message}`;
            if (type === 'error') entry.className += ' log-error';
            if (type === 'success') entry.className += ' log-success';
            box.appendChild(entry);
            box.scrollTop = box.scrollHeight;
            console.log(`[${type}] ${message}`);
        }
        async function loadAssets() {
            try {
                log("1. Försöker hämta 'tfjs_model/metadata.json'...");
                const metaResponse = await fetch('tfjs_model/metadata.json');
                if (!metaResponse.ok) throw new Error(`Kunde inte hitta metadata.json (Status: ${metaResponse.status})`);
metadata = await metaResponse.json();
log("✅ Metadata laddad.", 'success');
log("2. Försöker hämta 'tfjs_model/model.json'...");
model = await tf.loadLayersModel('tfjs_model/model.json');
log("✅ AI-modellen laddad!", 'success');
const btn = document.getElementById('predictBtn');
btn.disabled = false;
btn.innerText = "Analysera text";
// Värm upp modellen med korrekt shape [1, 256]
tf.tidy(() => {
model.predict(tf.zeros([1, SEQUENCE_LENGTH]));
});
log("Redo för input.");
} catch (err) {
log("KRITISKT FEL: " + err.message, 'error');
if (err.message.includes('404')) {
log("TIPS: Kontrollera att mappen heter 'tfjs_model'.", 'error');
}
}
}
loadAssets();
function tokenize(text) {
const words = text.toLowerCase().replace(/[.,!?;:]/g, '').split(/\s+/);
const wordIndex = metadata.word_index;
const OOV_INDEX = 1;
const PAD_INDEX = 0;
const sequence = words.map(word => {
return wordIndex[word] || OOV_INDEX;
});
// Padda till exakt 256
const paddedSequence = new Array(SEQUENCE_LENGTH).fill(PAD_INDEX);
for (let i = 0; i < Math.min(sequence.length, SEQUENCE_LENGTH); i++) {
paddedSequence[i] = sequence[i];
}
return paddedSequence;
}
async function runPrediction() {
const text = document.getElementById('textInput').value;
if (!text) { log("Ingen text."); return; }
try {
log(Analyserar: "${text}"...);
const inputIndices = tokenize(text);
// HÄR VAR FELET INNAN:
// Vi använder nu SEQUENCE_LENGTH (256) istället för metadata.max_len
const inputTensor = tf.tensor2d([inputIndices], [1, SEQUENCE_LENGTH]);
const prediction = model.predict(inputTensor);
const score = prediction.dataSync()[0];
const resultDiv = document.getElementById('result');
const percent = (score * 100).toFixed(1);
log(Resultat: ${percent}% (Råvärde: ${score}), 'success');
if (score > 0.5) {
resultDiv.innerText = Positivt! (${percent}%) ✅;
resultDiv.style.color = "green";
} else {
resultDiv.innerText = Negativt/Neutralt (${percent}%) ❌;
resultDiv.style.color = "#d00";
}
inputTensor.dispose();
prediction.dispose();
} catch (e) {
log("Fel vid analys: " + e.message, 'error');
}
}
</script>
</body>
</html>
