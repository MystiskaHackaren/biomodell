<script>
    let model;
    let metadata;
    const SEQUENCE_LENGTH = 256;
    const btn = document.getElementById('predictBtn');

    function log(message, type = 'info') {
        const box = document.getElementById('debug-box');
        const entry = document.createElement('div');
        entry.className = 'log-entry';
        const time = new Date().toLocaleTimeString();
        entry.innerHTML = `<span style="color:#888">[${time}]</span> ${message}`;
        if (type === 'error') entry.className += ' log-error';
        if (type === 'success') entry.className += ' log-success';
        box.appendChild(entry);
        box.scrollTop = box.scrollHeight;
        console.log(`[${type.toUpperCase()}] ${message}`);
    }

    async function loadAssets() {
        try {
            log("Startar laddning av metadata och modell...");

            // Försök metadata först
            log("Hämtar metadata från './tfjs_model/metadata.json'...");
            const metaResponse = await fetch('./tfjs_model/metadata.json');
            if (!metaResponse.ok) {
                throw new Error(`Metadata 404 eller fel: ${metaResponse.status} - ${metaResponse.statusText}`);
            }
            metadata = await metaResponse.json();
            log("✅ Metadata OK (word_index laddad)", 'success');

            // Sedan modellen
            log("Hämtar modell från './tfjs_model/model.json'...");
            model = await tf.loadLayersModel('./tfjs_model/model.json');
            log("✅ Modell laddad framgångsrikt!", 'success');

            // Värm upp modellen (dummy predict)
            tf.tidy(() => {
                model.predict(tf.zeros([1, SEQUENCE_LENGTH]));
            });
            log("Modell uppvärmd och redo för prediktioner.", 'success');

            // Aktivera knappen bara om allt lyckades
            btn.disabled = false;
            btn.innerText = "Analysera text";
            btn.style.background = "linear-gradient(135deg, #00ff9d, #00bfff)"; // cool grön-blå när redo

        } catch (err) {
            log("KRITISKT FEL under laddning: " + err.message, 'error');
            console.error(err);

            if (err.message.includes('404')) {
                log("Vanligt fel: Kolla att mappen heter exakt 'tfjs_model' och att model.json + .bin-filen finns uppladdade på GitHub Pages.", 'error');
                log("Testa manuellt: Öppna https://dittnamn.github.io/biomodell/tfjs_model/model.json i ny flik – ska visa JSON!", 'error');
            } else if (err.message.includes('batchInputShape') || err.message.includes('InputLayer')) {
                log("Modellkompatibilitetsfel (vanligt med Keras 3.x-export). Du behöver troligen fixa InputLayer i model.json som tidigare tips.", 'error');
            }

            // Visa alert vid totalt misslyckande
            alert("Modellen kunde inte laddas!\n\nFel: " + err.message + "\n\nKolla debug-loggen och konsolen (F12).");

            // Försök ändå aktivera knappen men visa varning (så användaren kan se debug)
            btn.disabled = false;
            btn.innerText = "Försök analysera (modell ej laddad)";
            btn.style.background = "#ff4444";
        }
    }

    // Starta laddningen direkt
    loadAssets();

    // Timeout-varning efter 15 sekunder
    setTimeout(() => {
        if (btn.disabled) {
            log("Laddning tar väldigt lång tid (>15s) – troligt nätverks- eller path-fel.", 'error');
        }
    }, 15000);

    async function runPrediction() {
        const text = document.getElementById('textInput').value.trim();
        if (!text) {
            log("Ingen text inmatad.", 'error');
            return;
        }

        if (!model) {
            log("Modellen är inte laddad ännu – vänta eller kolla fel i debug.", 'error');
            return;
        }

        try {
            log(`Analyserar: "${text}" ...`);
            const inputIndices = tokenize(text);
            const inputTensor = tf.tensor2d([inputIndices], [1, SEQUENCE_LENGTH]);
            const prediction = model.predict(inputTensor);
            const score = prediction.dataSync()[0];
            const percent = (score * 100).toFixed(1);

            const resultDiv = document.getElementById('result');
            if (score > 0.5) {
                resultDiv.innerText = `Positivt! (${percent}%) ✅`;
                resultDiv.style.color = "#00ff9d";
            } else {
                resultDiv.innerText = `Negativt (${percent}%) ❌`;
                resultDiv.style.color = "#ff5555";
            }

            log(`Prediktion klar: ${percent}% (råvärde ${score.toFixed(4)})`, 'success');

            // Städa upp tensorer
            inputTensor.dispose();
            prediction.dispose();
        } catch (e) {
            log("Fel vid prediktion: " + e.message, 'error');
            console.error(e);
        }
    }

    function tokenize(text) {
        const words = text.toLowerCase().replace(/[.,!?;:]/g, '').split(/\s+/).filter(w => w);
        const wordIndex = metadata?.word_index || {};
        const OOV_INDEX = 1;
        const PAD_INDEX = 0;
        const sequence = words.map(word => wordIndex[word] || OOV_INDEX);
        const padded = new Array(SEQUENCE_LENGTH).fill(PAD_INDEX);
        for (let i = 0; i < Math.min(sequence.length, SEQUENCE_LENGTH); i++) {
            padded[i] = sequence[i];
        }
        return padded;
    }
</script>
